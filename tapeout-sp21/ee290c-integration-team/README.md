# EE290C Integration Team

Main repository for the integration team.
This branch reflects the final delivery of OsciBear, including all components except for final flattened layouts (for which this repo contains pointers).
[Final industry design review slides](https://ucberkeley-ee290c.github.io/sp21/assets/review-final.pdf).

![Final Layout](resources/OsciBear.png?raw=true "Final Layout")

## Contents
 * Final top-level analog workspace including analog source schematics and layouts
 * Netlist models for blocks
 * Final Digital submodule
    * This doesn't have a dedicated README, so just refer to the original chipyard docs and the existing README
    * This submodule includes the final [AES](https://bwrcrepo.eecs.berkeley.edu/EE290C_EE194_tstech28/aes/-/tree/master), [DMA](https://bwrcrepo.eecs.berkeley.edu/EE290C_EE194_tstech28/dma/-/tree/master), [SHA3](https://github.com/ucb-bar/sha3/tree/74e41f579213549501ccf292d101f9db73ee2347), and [baseband](https://bwrcrepo.eecs.berkeley.edu/EE290C_EE194_tstech28/baseband/-/tree/1dab857720773d9933e3410974d92f24e5729b38) submodules in `generators`. They contain their own README's.

 * chip_generator.blend
    * This is a powerful layout planning tool, with support for pin-placement and lef-generation. 
    * Documentation included below, and the .blend can be found in `./scripts`
    * This requires [blender](https://blender.org) version 2.8 or higher.

## Final Top Level Layout (Analog + Integration)
The final top-level analog workspace exists in `./analog_workspace`
The top-level layouts are `integration_final/chip` and `integration_final/core`, with the final flattened+density-filled layouts in `delivery`.
The final analog-top layout (pre-flattening) is `radio_top_final/rf_top`. The flattened version is linked into the top-level core layouts. 

All layouts and schematics are included in this repo except for the flattened ones (final `digital` and `rf_top`). 
The digital layout can be generated by running the chipyard flow, importing the resulting gds into its own library, details in the Digital section.

The rf_top flattened layout can be generated by exporting `radio_top_final/rf_top` to gds with the `<> to []` option. 
This is necessary for LVS to pass at top-level, since we use verilog shells.
Then you can import that gds into a library and replace the current `rf_top` included in `integration_final/core`

###Chip Structure
```
chip
    io_ring_clamped
    core
        digital
        rf_top 
        power_top
        inter_block_wiring
    pad_wiring
    power_connections
```

### DRC
Runsets can be found in `./analog_workspace/calibre_run/runsets`. 
Use `drc_runset_top` for chip, `drc_runset_ip` for blocks (with density checking), and `drc_runset_block` for blocks (without density checking).

### LVS
We LVS our layouts against a combination of verilog and spice netlists. 
`chip` and `core` are both described by verilog shells, while the `io_ring`, `rf_top`, and `power_top` are described by schematics. 
The chipyard flow spits out a spice netlist for the `Digital` block.
To generate spice netlists from schematics, in the main cadence virtuoso window use `File > Export > CDL`: 
All the spice netlists required for `core` and `chip` LVS are included by `./models/spice/chip.lvs.sp` and `./models/spice/core.lvs.sp`, 
so if you regenerate any of these netlists, make sure to update relevant pointers.

Rules File For LVS:
```
/tools/tstech28c/PDK/1P9M_6X1Z1U/Calibre/lvs/calibre.lvs
```

### Chip LVS
Runset:
```
./analog_workspace/calibre_run/runsets/lvs_runset_chip
```

In case the runset doesn't fill in all the rquired parameters, use the MIXED format under netlist with the following verilog and spice files.

Verilog:
``` 
./models/verilog/chip.v
./models/verilog/core.v
``` 
Spice:
``` 
./models/chip.lvs.sp
```
The `chip.lvs.sp` includes all other required dependencies.

Additional LVS Options:
```
Power Nets: P_VDD_D, P_VDD_A, P_IO_PWR
Ground Nets: P_GND
```

### Core LVS
Runset:
```
./analog_workspace/calibre_run/runsets/lvs_runset_core
```
Connect nets by name:
```
cpu_ref_clk
```
In case the runset doesn't fill in all the rquired parameters, use the MIXED format under netlist with the following verilog and spice files.
Verilog:
``` 
./models/verilog/core.v
``` 
Spice:
``` 
./models/core.lvs.sp
```
The `core.lvs.sp` includes all other required dependencies.

### Blackbox LVS
Sometimes it is desirable to blackbox top-level LVS, to reduce the number of errors that are reported when it is known that subblocks pass LVS.
For this, under LVS Options, under LVS Box, uncheck `Use LVS Box related settings from rules`, and add the modules to blackbox.
If you do this, you'll want to replace the spice netlists with verilog shells. 
The verilog shells of each block are included in `./models/verilog`. 
The spice files to be included then will be the original contents of `chip.lvs.sp` or `core.lvs.sp` minus the spice files for the blackboxed modules.

Make sure to run LVS without blackboxing once Blackbox LVS passes.

## Digital Top (Chipyard) Notes
These notes are by the integration team and are limited in scope.
A few things to keep in mind when using Chipyard are that the "chip_top" that is spat out from the scala-to-verilog flow includes io-cells which is incompatible with the manual top-level flow.
As such our compute-complex team used the "digital_top" with a custom wrapper to make changes necessary to interface with the io-ring. 
(For example, chipyard uses active high enables, while the io-cells in this process use active low. The necessary inverters were added to this wrapper.)

## Chip Generator (Floorplanning and Lef Generation Tool)
This is copied from the README in the blend.
The blend should be in `scripts/chip_generator.blend`.
Using the blend requires [Blender](https:\\www.blender.org) version 2.80 or higher.

Written by Kareem Ahmad, with initial lef generation by Troy Sheldon.

![Layout Plan](resources/layout_plan.png?raw=true "Layout Plan")

### Introduction 
This file is a general floorplanning and layout tool that can help with a large portion of 
the integration process. It can be used for early floorplanning, lef generation for pin placements
(for both the digital flow and skeleton layouts), and more. This README will begin by elaborating 
the contents of this .blend followed by introducing a few examples of its usage.

All units in this file, unless otherwise stated, are in mm.
All locations are measured from the bottom left corner of an item to the bottom left corner of
 its parent.

### Contents
#### verilog
 * This file contains the top-level verilog shell containing the main subblocks. 
    In this case, it is the core verilog, since that contains the most important 
    blocks (digital, power, and rf), and since the io_ring doesn\'t have pins you 
    can place arbitrarily.
 * The structure of modules in this file will be inferred by the parser.
 * Signals between blocks can have their sources and destinations annotated by a comment 
    at their declaration:
```
    wire [1:0] wire_from_digital_to_rf_and_power # DTOP RF PWR
```
    The names of modules in the comment should match their names in the verilog, the first is assumed 
    to be the source and all that follow are assumed to be the destinations
 * This verilog must be purely structural. It cannot have assignments of any kind.
    
#### classes.py
 * This file defines the main classes used by the other python files in this blend. 
    These main ones used by a user (not implementer):
```
class Module: A class that contains all data related to a module
    place(location, dimensions) : places this block in the layout plan at `location` with `dimension`
    place_pins(...)          : places a list of signal objects # see examples
    place_pins_connected(...): places pins by their connections to a list of signal objects # see examples
    place_pins_matched(...)  : places pins by regex matching # see examples
    place_block(name, offset, dimensions): places a subblock # see examples
    draw(): draws the visual representation in the 3D viewport
    write_lef(path): writes the corresponding lef to the path
    
place_sync, place_sync_v2(...): synchronizes pin placement across two modules for easy wiring
```
 * File also defines the colors used by pins on various metal layers, see "metal_color" in `classes.py`

#### parser.py
 * This file parses the top-level verilog. It also has the option to check it. 
 * The main function from a users point of view here is `parse_stack(module_names, parse, check)`
    * This function parses the verilog file. 
    * `module_names`: a list of the names of all submodules. It can contain more names than are required. 
        The names in the verilog (comments and module instantiation) must match these.
    * `parse`: a boolean expressing whether or not to parse the verilog
    * `check`: a boolean expressing whether or not to run checkers on the parsed verilog. 
        These include checkers to make sure that signals with comments indicating they should 
        connect to certain modules, are actually connected to those modules, a sort of sanity checking.
        It is allowed to ignore these warnings.
    * `return`: the function returns a `Data` object containing all parsed data
 * This file also defines the `VParser` class which does the parsing/checking. It is also the class returned by `parse_stack`. You should only touch this if you want 
    to expand/modify parsing behavior.
 * Running the `parser.py` file on its own, runs the parsing and checking steps. You can see in the comments
    of the file how one may go about debugging connections.

#### lef.py
 * Defines the lef class and all that is needed to make lefs

#### verilog_data.py
 * defines the pad arrays and their order of placement
 * this is essentially `import *`-ed into the main file

#### parameters.py
 * defines some parameters used by the other files
 * this is essentially `import *`-ed into the main file

### Examples
You can hit `Alt+P` or click the play icon at the top of the script window to run the script at any time.

![Run Button](resources/run_button.png?raw=true "Run Button")

Make sure your cursor is hovering over the correct panel since keyboard shortcuts are context-sensitive.


#### Header
Pretty much any file you will use should start with this header. This manages the weird imports when using multiple
files in blender.
```
import bpy, math, pathlib
from mathutils import Vector
classes = bpy.data.texts["classes.py"].as_module()
parser  = bpy.data.texts["parser.py"].as_module()
draw    = bpy.data.texts["draw.py"].as_module()

def dump_module(name):
    body = bpy.data.texts[name + ".py"].as_string()
    exec(body, globals())

dump_module("parameters")
dump_module("verilog_data")

def delete_all_blender_objects():
    for msh in bpy.data.meshes:
        bpy.data.meshes.remove(msh)
    for txt in bpy.data.curves:
        bpy.data.curves.remove(txt)
    for obj in bpy.data.objects:
        bpy.data.objects.remove(obj)

```

#### Layout Planning (example_plan.py)
This example shows how one can place subblocks to help negotiate area allocations.
We begin by cleaning the viewport by deleting all blender objects. 
```
# (INSERT HEADER)     
if __name__ == "__main":
    delete_all_blender_objects()
```
Then we draw the main outline of our chip. In this case we will have a tall 500um x 1mm chip.
This is a general drawing function and can be used for pretty much anything.
```
    draw.make_rect((0,0,0), 0.500, 1.000, "ChipTop", GREEN)
```
Now we create our io_ring. 
The `draw` library includes a `construct_pad_array` function 
`draw.construct_pad_array(Vector[3]: location, float[2]: dimensions, Vector[3]: pitch, string[:]: names)`
In this example we will place 4 io_cells at the top and bottom of the chip. We use ZOFF for the z-coordinate 
for an easy to read visual.
```
    draw.construct_pad_array(Vector((0.035, 0.035, ZOFF)), (0.1, 0.1), Vector((0.11, 0, 0)), ["VDD", "GND", "RX", "TX"])
    draw.construct_pad_array(Vector((0.035, 0.865, ZOFF)), (0.1, 0.1), Vector((0.11, 0, 0)), ["GPIO_1", "GPIO_2", "GPIO_3", "GPIO_4"])
```

Next we construct empty modules (since this example is not parsing verilog), place and draw them.
```
    digital = classes.Module("digital")
    digital.place((0.035, 0.400), (0.430, 0.440))
    digital.draw()
    
    analog  = classes.Module("analog")
    analog.place((0.035, 0.150), (0.430, 0.220))
    analog.draw()
```

Note the `.draw()` function is required to actually draw anything. This should generally occur after all subblock
and pin placements.

Now we can add some subblocks. `Module.place_block(string: name, float[2]: location, float[2]: dimensions)`
These blocks are placed relative to the module.
```
    digital.place_block("SRAM", (0.010, 0.010), (0.050, 0.420))
    digital.place_block("CPU" , (0.170, 0.010), (0.250, 0.420))
    digital.draw()
```

Other tools useful for floorplanning include the ruler and grease pencil tools on the left side of the 3D viewport. 
That sidebar can be toggled by `T` if it ever disappears.

![Toolbar](resources/toolbar.png?raw=true "Toolbar")

#### Pin Placement
For this example, we will build off of the previous example and note the key differences.
For placing pins, first and foremost, we need a top-level verilog shell. 
In this example we will use `example.v`:

```
module chip(
    inout GPIO_0,
    inout GPIO_1,
    inout GPIO_2,
    inout GPIO_3,
    input VDD,
    input GND,
    input RX,
    output TX
);

wire vdd_d, gnd; // RF DTOP
wire [4:0] adc_out; // RF DTOP
wire [3:0] data_in; // DTOP RF

digital_top DTOP(
    .gpio({GPIO_0, GPIO_1, GPIO_2, GPIO_3}),
    .rx_data(adc_out),
    .tx_data(data_in),
    .vdd(vdd_d),
    .gnd(gnd)
)

analog_top RF(
    .vdd(VDD),
    .gnd(GND),
    .vdd_d(vdd_d),
    .rx(RX),
    .tx(TX),
    .adc_out(adc_out),
    .data_in(data_in)
)

endmodule
```

Since we have a source verilog, in this example we won't manually create the modules. 
Instead we'll use the parser. 
`parser.parser_verilog(string[:]: module_names, string: verilog_filename, bool: parse, bool: run_checker)`

```
if __name__ == "__main__":
    # ... (draw chip, io_ring) ...
    data = parser.parse_stack(["RF", "DTOP"], "example.v", True, False)
    digital = data.modules["DTOP"]
    analog = data.modules["DTOP"]
```
Since these are parsed modules, they have `pins` filled in.
This means that we can place pins. To do this, we have a few options.

*Placing Pin Objects*

If you have the desired signal objects at hand, you can use `Module.place_pins(offset, pin_size, pin_pitch, metal, signals, vertical=False, reverse=False)`
 * `offset`: float[2] giving the location of pins relative to bottom left corner of module. 
 * `pin_size`: float giving the size of a pin
 * `pin_pitch`: float giving the spacing between pins (including pin size)
 * `metal`: integer giving the metal layer used (for lef and choosing color (see `classes.py` for color defs))
 * `signals`: list of Signal instances to be placed
 * `vertical`: bool selecting whether the pitch should be interpreted vertically or horizontally
 * `reverse`: reverse the order of pins being placed
```
    GPIO_PADS = [digital.mapping[signal.name] for signal in data.pads if "GPIO" in signal.name]
    digital.place_pins((0.050, digital.top(0.010)), 0.010, 0.11, 7, GPIO_PADS, False, False)
```
Notice the helper function `digital.top(y)` which gives the y coordinate that is `y` below the top of the module. 
There is a similar `digital.right(x)` helper function.

Also, be careful when using this function since unlike the alternatives, it does not check that those pins exist
on the attached module.

This same operation can be made more simply with `Module.place_pins_connected` which places pins by their connections.
This has the same arguments and order as `place_pins` except that `signals` is now signals that are connected to the 
module's pins. '

```
    GPIO_PADS = [signal for signal in data.pads if "GPIO" in signal.name]
    digital.place_pins((0.050, digital.top(0.010)), 0.010, 0.11, 7, GPIO_PADS, False, False)
```

*Placing Pins by Names*

A more common case is wanting to place pins by their name. For this use
`Module.place_pins_matched(offset, size, pitch, metal, expressions, use_connection=True, vertical=False, reverse=False)`
This is nearly identical to the previous options except that `signals` is replaced by `expressions`, and is now
a list of regex expressions. These expressions are matched against unconnected pins when `use_connection` is false, 
and against the wires they connect to when `use_connection` is true. 
```
    analog.place_pins_matched((0.270, 0.000), 0.010, 0.11, 7, [".X"], True, False, False)
```
This will match and place the `RX` and `TX` pins.

*Synchronizing Pin Placement*

There are many cases where you want to place pins that will be connected to each other. 
Ideally these pins should line up. For this, the classes library includes 
`classes.place_sync` and `classes.place_sync_v2`. 
Both do the same thing with slightly different argument structure.

`classes.place_sync(module_a, offset_a, module_b, offset_b, expressions, wires, size, pitch, metal, vertical, reverse)`
 * `module_a` and `module_b` are the two modules in question
 * `offset_a` and `offset_b` are the offsets of pins for each respectively
 * `wires` is the list of wires to search when matching expressions. Usually `data.wires` should be fine.
All other arguments are just as before.

```
    classes.place_sync(digital, (0.050, 0), analog, (0.050, 0), [".*"], data.wires)
```

`classes.place_sync_v2()` reorganizes the arguments slightly in a manner that is more useful when synchronizing 
pin placements for many groups of signals. See `main.py` for its use or `classes.py` to see how its arguments map
to the underlying `place_sync` implementation.

Note: all matching-based pin placements automatically ignore previously placed pins.

Finally we can generate lefs:
``` 
    digital.write_lef("path/to/digital.lef")
    analog.write_lef("path/to/analog.lef")
```

#### Full Example (main.py)
This example is the final chip from sp21. Feel free to poke around and see at how it works.


# Original README

## Expectations
* Each team should create a team repository for their work.
* Each team should do their own block level tests once blocks are designed.
* This repo should include a README.md specifying the i/o of their block, and an overview of block functionality.
* This repo should also include a full SoC block diagram.
* Each team should also keep the [Spec Sheet](https://docs.google.com/spreadsheets/d/1VxQVAQvwGnti4-fcNHREf_C5IoeT04Js7yG1sI7ofMQ/edit) up to date with current power/frequency requirements.
* For organization, presentations can be uploaded to this [Google Drive Folder](https://drive.google.com/drive/folders/1jps7jbcjx6UevOgS5p0U8z3zrSVS9wC6?usp=sharing).
* Each team should nominate one or two representatives to join the "integration-gang" Slack channel as point people for communication between teams.
